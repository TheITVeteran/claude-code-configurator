name: 'Publish to APT Repository'

on:
  workflow_call:
    inputs:
      version:
        description: 'Version to publish'
        required: true
        type: string
      dry_run:
        description: 'Dry run mode'
        required: false
        default: false
        type: boolean
    outputs:
      repository_created:
        description: 'Whether the APT repository was created'
        value: ${{ jobs.publish-apt.outputs.repository_created }}

  workflow_dispatch:
    inputs:
      version:
        description: 'Version to publish (e.g., v1.0.0)'
        required: true
        type: string
      dry_run:
        description: 'Dry run (no actual repository creation)'
        required: false
        default: false
        type: boolean

defaults:
  run:
    shell: bash
    working-directory: packages/caci

env:
  NODE_OPTIONS: --max-old-space-size=4096

permissions:
  contents: read

jobs:
  publish-apt:
    name: 'APT Repository Publishing'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      repository_created: ${{ steps.create_repo.outputs.repository_created }}

    steps:
      - name: Checkout code
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4.2.0
        with:
          fetch-depth: 0
          ref: ${{ inputs.version == 'master' && github.ref || inputs.version }}

      - name: Download DEB package (if available from artifacts)
        id: download_deb
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
        with:
          name: caci-deb-package
          path: packages/caci
        continue-on-error: true

      - name: Check for existing DEB package
        id: check_deb
        run: |
          if ls caci_*.deb 1> /dev/null 2>&1; then
            echo "deb_exists=true" >> $GITHUB_OUTPUT
            echo "📦 Found existing DEB package: $(ls caci_*.deb)"
          else
            echo "deb_exists=false" >> $GITHUB_OUTPUT
            echo "📦 No DEB package found, will create one"
          fi

      - name: Setup Node.js (if needed)
        if: steps.check_deb.outputs.deb_exists == 'false' && inputs.dry_run == false
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.1.0
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: 'packages/caci/package-lock.json'

      - name: Create DEB package (if not available)
        if: steps.check_deb.outputs.deb_exists == 'false'
        run: |
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "🔍 DRY RUN - Would create DEB package if not available"
            # Create a mock DEB file for testing APT repository structure
            VERSION="${{ inputs.version }}"
            DEB_VERSION=${VERSION#v}
            if [ "$VERSION" = "master" ]; then
              DEB_VERSION="$(date +%Y%m%d)-$(git rev-parse --short HEAD)"
            fi
            touch "caci_${DEB_VERSION}_all.deb"
            exit 0
          fi

          echo "📦 DEB package not found in artifacts, creating it..."

          # Install DEB packaging tools
          sudo apt-get update
          sudo apt-get install -y dpkg-dev build-essential fakeroot

          # Install dependencies and build
          npm install
          npm run build

          VERSION="${{ inputs.version }}"
          DEB_VERSION=${VERSION#v}

          # Handle master branch with proper versioning
          if [ "$VERSION" = "master" ]; then
            PACKAGE_VERSION=$(node -p "require('./package.json').version")
            DEB_VERSION="${PACKAGE_VERSION}-$(date +%Y%m%d)-$(git rev-parse --short HEAD)"
            echo "📦 Using development version: $DEB_VERSION"
          fi

          echo "📦 Creating DEB package for CACI v$DEB_VERSION..."

          # Create package directory structure
          mkdir -p caci_${DEB_VERSION}_all/DEBIAN
          mkdir -p caci_${DEB_VERSION}_all/usr/local/lib/nodejs/caci
          mkdir -p caci_${DEB_VERSION}_all/usr/local/bin

          # Copy application files
          cp -r dist/* caci_${DEB_VERSION}_all/usr/local/lib/nodejs/caci/

          # Copy node_modules (check local first, then root)
          if [ -d "node_modules" ]; then
            echo "📂 Copying local node_modules directory..."
            cp -r node_modules caci_${DEB_VERSION}_all/usr/local/lib/nodejs/caci/
          elif [ -d "../../node_modules" ]; then
            echo "📂 Copying root node_modules directory..."
            cp -r ../../node_modules caci_${DEB_VERSION}_all/usr/local/lib/nodejs/caci/
          else
            echo "❌ Error: node_modules directory not found"
            echo "Current directory contents:"
            ls -la
            exit 1
          fi

          cp package.json caci_${DEB_VERSION}_all/usr/local/lib/nodejs/caci/
          mkdir -p caci_${DEB_VERSION}_all/usr/local/lib/nodejs/caci/bin/
          cp bin/caci caci_${DEB_VERSION}_all/usr/local/lib/nodejs/caci/bin/
          chmod +x caci_${DEB_VERSION}_all/usr/local/lib/nodejs/caci/bin/caci

          # Create control file
          cat > caci_${DEB_VERSION}_all/DEBIAN/control << EOF
          Package: caci
          Version: ${DEB_VERSION}
          Section: devel
          Priority: optional
          Architecture: all
          Depends: nodejs (>= 18.0.0), npm
          Installed-Size: $(du -sk caci_${DEB_VERSION}_all/usr | cut -f1)
          Maintainer: CACI Development Team <noreply@github.com>
          Description: Code Assistant Configuration Interface
           CACI is an intelligent CLI tool that automates Claude Code project 
           configuration by analyzing requirements and using AI to recommend 
           relevant agents, commands, MCPs, and hooks from a large component pool.
           .
           This package provides the CACI command-line interface for easy
           project setup and configuration management.
          Homepage: https://github.com/elad12390/claude-code-configurator
          EOF

          # Create postinst script to create symlink
          cat > caci_${DEB_VERSION}_all/DEBIAN/postinst << 'EOF'
          #!/bin/bash
          set -e

          # Create symlink
          ln -sf /usr/local/lib/nodejs/caci/bin/caci /usr/local/bin/caci

          # Ensure correct permissions
          chmod +x /usr/local/lib/nodejs/caci/bin/caci
          chmod +x /usr/local/bin/caci

          echo "CACI installed successfully!"
          echo "Usage: caci configure"
          echo "Help:  caci --help"
          EOF
          chmod 755 caci_${DEB_VERSION}_all/DEBIAN/postinst

          # Create prerm script to remove symlink
          cat > caci_${DEB_VERSION}_all/DEBIAN/prerm << 'EOF'
          #!/bin/bash
          set -e
          rm -f /usr/local/bin/caci
          EOF
          chmod 755 caci_${DEB_VERSION}_all/DEBIAN/prerm

          # Build the package
          dpkg-deb --build caci_${DEB_VERSION}_all

          echo "✅ DEB package created: caci_${DEB_VERSION}_all.deb"
          ls -la caci_*.deb

      - name: Install APT repository tools
        run: |
          sudo apt-get update
          sudo apt-get install -y dpkg-dev apt-utils gnupg2

      - name: Setup GPG for package signing
        run: |
          echo "🔑 Setting up GPG for package signing..."

          # Setup GPG home directory with proper permissions
          export GNUPGHOME="$HOME/.gnupg"
          mkdir -p "$GNUPGHOME"
          chmod 700 "$GNUPGHOME"

          # Configure GPG for non-interactive use
          echo "use-agent" > "$GNUPGHOME/gpg.conf"
          echo "pinentry-mode loopback" >> "$GNUPGHOME/gpg.conf"
          echo "batch" >> "$GNUPGHOME/gpg.conf"
          echo "no-tty" >> "$GNUPGHOME/gpg.conf"

          # Import GPG private key for signing
          if [ -n "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            echo "🔓 Importing production GPG key..."
            
            # Write key to temporary file to handle formatting issues
            echo "${{ secrets.GPG_PRIVATE_KEY }}" > /tmp/gpg_key.asc
            
            # Import the key with error handling
            if gpg --import --batch --yes --pinentry-mode loopback /tmp/gpg_key.asc; then
              echo "✅ GPG key imported successfully"
            else
              echo "❌ Failed to import GPG key"
              echo "🔍 Checking key format..."
              head -5 /tmp/gpg_key.asc
              exit 1
            fi
            
            # Clean up temporary file
            rm -f /tmp/gpg_key.asc
            
            # Get the key ID with more robust extraction
            KEY_ID=$(gpg --list-secret-keys --with-colons 2>/dev/null | grep '^sec:' | cut -d: -f5 | head -1)
            if [ -z "$KEY_ID" ]; then
              # Fallback method
              KEY_ID=$(gpg --list-secret-keys --keyid-format LONG 2>/dev/null | grep '^sec' | sed 's/.*\/\([A-F0-9]*\).*/\1/' | head -1)
            fi
            
            if [ -n "$KEY_ID" ]; then
              # Set ultimate trust for the key
              echo "$KEY_ID:6:" | gpg --import-ownertrust --batch --yes
              echo "✅ GPG key imported and trusted: $KEY_ID"
            else
              echo "❌ Failed to extract key ID from imported key"
              echo "🔍 Available keys:"
              gpg --list-secret-keys --keyid-format LONG
              exit 1
            fi
          else
            echo "⚠️ No GPG_PRIVATE_KEY secret found, creating temporary key for demo"
            # Create a temporary GPG key for development (NOT for production)
            cat > /tmp/gpg_batch.txt <<EOF
          %no-protection
          Key-Type: RSA
          Key-Length: 2048
          Subkey-Type: RSA
          Subkey-Length: 2048
          Name-Real: CACI Package Signing
          Name-Email: packages@caci.dev
          Expire-Date: 1y
          %commit
          EOF
            
            if gpg --batch --gen-key /tmp/gpg_batch.txt; then
              echo "✅ Temporary GPG key created"
            else
              echo "❌ Failed to create temporary GPG key"
              exit 1
            fi
            
            # Get the key ID
            KEY_ID=$(gpg --list-secret-keys --with-colons 2>/dev/null | grep '^sec:' | cut -d: -f5 | head -1)
            if [ -n "$KEY_ID" ]; then
              echo "✅ Temporary GPG key created: $KEY_ID"
            else
              echo "❌ Failed to get key ID from generated key"
              exit 1
            fi
            
            # Clean up batch file
            rm -f /tmp/gpg_batch.txt
          fi

          # Verify GPG setup
          echo "📝 GPG setup verification:"
          if gpg --list-secret-keys --keyid-format LONG; then
            echo "✅ GPG secret keys listed successfully"
          else
            echo "❌ No GPG secret keys found"
            exit 1
          fi

          # Store the signing key ID for later use
          if [ -n "$KEY_ID" ]; then
            echo "GPG_KEY_ID=$KEY_ID" >> $GITHUB_ENV
            echo "🔑 Using GPG key ID: $KEY_ID"
          else
            echo "❌ No GPG key ID available"
            exit 1
          fi

          # Test GPG signing capability
          echo "🧪 Testing GPG signing capability..."
          echo "test" | gpg --batch --yes --armor --detach-sign --default-key "$KEY_ID" > /tmp/test.sig
          if [ $? -eq 0 ]; then
            echo "✅ GPG signing test successful"
            rm -f /tmp/test.sig
          else
            echo "❌ GPG signing test failed"
            exit 1
          fi

      - name: Create APT repository
        id: create_repo
        run: |
          VERSION="${{ inputs.version }}"
          DEB_VERSION=${VERSION#v}

          # Handle master branch with proper versioning
          if [ "$VERSION" = "master" ]; then
            PACKAGE_VERSION=$(node -p "require('./package.json').version")
            DEB_VERSION="${PACKAGE_VERSION}-$(date +%Y%m%d)-$(git rev-parse --short HEAD)"
            echo "📦 Using development version: $DEB_VERSION"
          fi

          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "🔍 DRY RUN - Would create APT repository for version $DEB_VERSION"
            echo "repository_created=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "📦 Creating APT repository for CACI v$DEB_VERSION..."

          # Create repository directory structure
          mkdir -p apt-repo/pool/main/c/caci
          mkdir -p apt-repo/dists/stable/main/binary-amd64
          mkdir -p apt-repo/dists/stable/main/binary-arm64
          mkdir -p apt-repo/dists/stable/main/source

          # Copy DEB package to pool
          DEB_FILE=$(ls caci_*.deb | head -1)
          if [ ! -f "$DEB_FILE" ]; then
            echo "❌ No DEB file found"
            echo "Available files:"
            ls -la
            exit 1
          fi

          echo "📦 Found DEB package: $DEB_FILE"
          cp "$DEB_FILE" apt-repo/pool/main/c/caci/

          echo "✅ Repository structure created"
          ls -la apt-repo/pool/main/c/caci/
          echo "repository_created=true" >> $GITHUB_OUTPUT

      - name: Generate APT repository metadata
        if: inputs.dry_run == false
        run: |
          cd apt-repo

          echo "📝 Generating APT repository metadata..."

          # Generate Packages file for binary-amd64
          dpkg-scanpackages pool/main > dists/stable/main/binary-amd64/Packages
          gzip -k dists/stable/main/binary-amd64/Packages

          # For now, copy amd64 to arm64 (since our package is architecture: all)
          cp dists/stable/main/binary-amd64/Packages dists/stable/main/binary-arm64/Packages
          cp dists/stable/main/binary-amd64/Packages.gz dists/stable/main/binary-arm64/Packages.gz

          # Create empty Sources file
          touch dists/stable/main/source/Sources
          gzip -k dists/stable/main/source/Sources

          # Generate Release file
          cat > dists/stable/Release << EOF
          Origin: CACI
          Label: CACI Package Repository
          Suite: stable
          Codename: stable
          Version: 1.0
          Architectures: amd64 arm64
          Components: main
          Description: CACI (Code Assistant Configuration Interface) Package Repository
          Date: $(date -Ru)
          EOF

          # Add file hashes to Release
          echo "MD5Sum:" >> dists/stable/Release
          find dists/stable -name "Packages*" -o -name "Sources*" | while read file; do
            echo " $(md5sum "$file" | cut -d' ' -f1) $(stat -c%s "$file") ${file#dists/stable/}"
          done >> dists/stable/Release

          echo "SHA1:" >> dists/stable/Release
          find dists/stable -name "Packages*" -o -name "Sources*" | while read file; do
            echo " $(sha1sum "$file" | cut -d' ' -f1) $(stat -c%s "$file") ${file#dists/stable/}"
          done >> dists/stable/Release

          echo "SHA256:" >> dists/stable/Release
          find dists/stable -name "Packages*" -o -name "Sources*" | while read file; do
            echo " $(sha256sum "$file" | cut -d' ' -f1) $(stat -c%s "$file") ${file#dists/stable/}"
          done >> dists/stable/Release

          echo "✅ Release file generated"

      - name: Sign APT repository
        if: inputs.dry_run == false
        run: |
          cd apt-repo

          echo "🔏 Signing APT repository..."

          # Verify GPG environment is still available
          export GNUPGHOME="$HOME/.gnupg"

          if [ -z "$GPG_KEY_ID" ]; then
            echo "❌ No GPG key ID found in environment"
            echo "🔍 Checking available GPG keys:"
            gpg --list-secret-keys --keyid-format LONG
            exit 1
          fi

          echo "🔑 Using GPG key: $GPG_KEY_ID"

          # Verify the key exists and is usable
          if ! gpg --list-secret-keys "$GPG_KEY_ID" >/dev/null 2>&1; then
            echo "❌ GPG key $GPG_KEY_ID not found in keyring"
            echo "🔍 Available keys:"
            gpg --list-secret-keys --keyid-format LONG
            exit 1
          fi

          # Sign the Release file with specific key
          echo "🔏 Creating detached signature for Release file..."
          if gpg --batch --yes --detach-sign --armor --pinentry-mode loopback --default-key "$GPG_KEY_ID" -o dists/stable/Release.gpg dists/stable/Release; then
            echo "✅ Release.gpg created successfully"
          else
            echo "❌ Failed to create Release.gpg"
            exit 1
          fi

          # Create clearsigned InRelease file
          echo "🔏 Creating clearsigned InRelease file..."
          if gpg --batch --yes --clearsign --pinentry-mode loopback --default-key "$GPG_KEY_ID" -o dists/stable/InRelease dists/stable/Release; then
            echo "✅ InRelease created successfully"
          else
            echo "❌ Failed to create InRelease"
            exit 1
          fi

          echo "✅ Repository signed successfully"

          # Verify signatures
          echo "🔍 Verifying signatures..."
          if gpg --verify dists/stable/Release.gpg dists/stable/Release; then
            echo "✅ Release.gpg signature verified"
          else
            echo "❌ Release.gpg signature verification failed"
            exit 1
          fi

          if gpg --verify dists/stable/InRelease; then
            echo "✅ InRelease signature verified"
          else
            echo "❌ InRelease signature verification failed"
            exit 1
          fi

          # Export public key for users
          echo "📤 Exporting public key for users..."
          if gpg --armor --export "$GPG_KEY_ID" > ../caci-archive-keyring.gpg; then
            echo "✅ Public key exported successfully"
            echo "📊 Public key size: $(wc -c < ../caci-archive-keyring.gpg) bytes"
          else
            echo "❌ Failed to export public key"
            exit 1
          fi

          # Verify exported key is not empty
          if [ ! -s "../caci-archive-keyring.gpg" ]; then
            echo "❌ Exported public key file is empty"
            exit 1
          fi

          echo "📋 Repository signing completed successfully!"

      - name: Create installation assets
        if: inputs.dry_run == false
        run: |
          VERSION="${{ inputs.version }}"

          # Create installation script for APT repository
          cat > install-caci-apt.sh << 'EOF'
          #!/bin/bash
          # CACI APT Repository Installation Script

          set -e

          echo "🔧 Adding CACI APT Repository..."
          echo "=================================="

          # Check if running as root or with sudo
          if [ "$EUID" -ne 0 ]; then
              echo "❌ This script requires root privileges."
              echo "💡 Please run with: sudo $0"
              exit 1
          fi

          # Check if running on Debian/Ubuntu
          if ! command -v apt-get &> /dev/null; then
              echo "❌ APT not found. This script is for Debian/Ubuntu systems only."
              exit 1
          fi

          # Add GPG key
          echo "🔑 Adding CACI repository GPG key..."
          curl -fsSL https://github.com/elad12390/claude-code-configurator/releases/latest/download/caci-archive-keyring.gpg | gpg --dearmor -o /usr/share/keyrings/caci-archive-keyring.gpg

          # Add repository to sources.list.d
          echo "📦 Adding CACI repository..."
          echo "deb [signed-by=/usr/share/keyrings/caci-archive-keyring.gpg] https://github.com/elad12390/claude-code-configurator/releases/latest/download/apt-repo stable main" > /etc/apt/sources.list.d/caci.list

          # Update package lists
          echo "🔄 Updating package lists..."
          apt-get update

          # Install CACI
          echo "🚀 Installing CACI..."
          apt-get install -y caci

          echo ""
          echo "✅ CACI installed successfully via APT!"
          echo "=================================="
          echo "💡 Usage: caci configure"
          echo "📖 Help:  caci --help"
          echo "🔧 Update: sudo apt update && sudo apt upgrade caci"
          echo ""
          echo "🎉 Happy coding with CACI!"
          EOF
          chmod +x install-caci-apt.sh

          # Create comprehensive installation documentation
          cat > APT-INSTALL.md << EOF
          # CACI APT Repository Installation

          ## Quick Install (Recommended)

          \`\`\`bash
          # Download and run the installation script
          curl -fsSL https://github.com/elad12390/claude-code-configurator/releases/latest/download/install-caci-apt.sh | sudo bash
          \`\`\`

          ## Manual Installation

          ### Step 1: Add GPG Key
          \`\`\`bash
          curl -fsSL https://github.com/elad12390/claude-code-configurator/releases/latest/download/caci-archive-keyring.gpg | sudo gpg --dearmor -o /usr/share/keyrings/caci-archive-keyring.gpg
          \`\`\`

          ### Step 2: Add Repository
          \`\`\`bash
          echo "deb [signed-by=/usr/share/keyrings/caci-archive-keyring.gpg] https://github.com/elad12390/claude-code-configurator/releases/latest/download/apt-repo stable main" | sudo tee /etc/apt/sources.list.d/caci.list
          \`\`\`

          ### Step 3: Update and Install
          \`\`\`bash
          sudo apt update
          sudo apt install caci
          \`\`\`

          ## Usage

          \`\`\`bash
          # Configure Claude Code project
          caci configure

          # Get help
          caci --help

          # Check version
          caci --version
          \`\`\`

          ## Updates

          \`\`\`bash
          # Update CACI to the latest version
          sudo apt update && sudo apt upgrade caci
          \`\`\`

          ## Uninstall

          ### Remove Package
          \`\`\`bash
          sudo apt remove caci
          \`\`\`

          ### Remove Repository (Optional)
          \`\`\`bash
          sudo rm /etc/apt/sources.list.d/caci.list
          sudo rm /usr/share/keyrings/caci-archive-keyring.gpg
          sudo apt update
          \`\`\`

          ## Troubleshooting

          ### Verify Installation
          \`\`\`bash
          caci --version
          which caci
          \`\`\`

          ### Check Repository Status
          \`\`\`bash
          apt policy caci
          apt-cache show caci
          \`\`\`

          ### Fix Dependencies
          \`\`\`bash
          sudo apt-get install -f
          \`\`\`
          EOF

          echo "✅ Installation assets created"

      - name: Upload APT repository artifacts
        if: inputs.dry_run == false
        uses: actions/upload-artifact@b4b15b8c7c6ac21ea08fcf65892d2ee8f75cf882 # v4.4.3
        with:
          name: caci-apt-repository
          path: |
            packages/caci/apt-repo/**
            packages/caci/caci-archive-keyring.gpg
            packages/caci/install-caci-apt.sh
            packages/caci/APT-INSTALL.md
          retention-days: 90

      - name: Test APT repository structure
        if: inputs.dry_run == false
        run: |
          echo "🧪 Testing APT repository structure..."

          # Verify repository structure
          if [ -d "apt-repo/dists/stable" ] && [ -d "apt-repo/pool/main" ]; then
            echo "✅ Repository structure is correct"
          else
            echo "❌ Repository structure is invalid"
            find apt-repo -type d | head -10
            exit 1
          fi

          # Verify essential files exist
          REQUIRED_FILES=(
            "apt-repo/dists/stable/Release"
            "apt-repo/dists/stable/Release.gpg"
            "apt-repo/dists/stable/InRelease"
            "apt-repo/dists/stable/main/binary-amd64/Packages"
            "apt-repo/dists/stable/main/binary-amd64/Packages.gz"
          )

          for file in "${REQUIRED_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "✅ Found: $file"
            else
              echo "❌ Missing: $file"
              exit 1
            fi
          done

          # Verify signed files exist and are not empty
          if [ -f "apt-repo/dists/stable/Release.gpg" ] && [ -s "apt-repo/dists/stable/Release.gpg" ]; then
            echo "✅ Release.gpg exists and is not empty"
          else
            echo "❌ Release.gpg missing or empty"
            exit 1
          fi

          if [ -f "apt-repo/dists/stable/InRelease" ] && [ -s "apt-repo/dists/stable/InRelease" ]; then
            echo "✅ InRelease exists and is not empty"
          else
            echo "❌ InRelease missing or empty"
            exit 1
          fi

          # Verify package exists
          if ls apt-repo/pool/main/c/caci/caci_*.deb 1> /dev/null 2>&1; then
            echo "✅ DEB package found in repository"
            ls -la apt-repo/pool/main/c/caci/
          else
            echo "❌ DEB package missing from repository"
            find apt-repo -name "*.deb" -type f
            exit 1
          fi

          # Verify public key was exported
          if [ -f "caci-archive-keyring.gpg" ] && [ -s "caci-archive-keyring.gpg" ]; then
            echo "✅ Public key exported successfully"
            echo "📊 Public key size: $(wc -c < caci-archive-keyring.gpg) bytes"
          else
            echo "❌ Public key export failed or file is empty"
            exit 1
          fi

          # Verify signature files contain proper GPG signatures
          if grep -q "BEGIN PGP SIGNATURE" apt-repo/dists/stable/Release.gpg; then
            echo "✅ Release.gpg contains valid PGP signature"
          else
            echo "❌ Release.gpg does not contain valid PGP signature"
            head -5 apt-repo/dists/stable/Release.gpg
            exit 1
          fi

          if grep -q "BEGIN PGP SIGNED MESSAGE" apt-repo/dists/stable/InRelease; then
            echo "✅ InRelease contains valid PGP signed message"
          else
            echo "❌ InRelease does not contain valid PGP signed message"
            head -5 apt-repo/dists/stable/InRelease
            exit 1
          fi

          echo "✅ APT repository testing completed successfully"

      - name: Create repository summary
        run: |
          VERSION="${{ inputs.version }}"
          DEB_VERSION=${VERSION#v}

          # Handle master branch with proper versioning
          if [ "$VERSION" = "master" ]; then
            PACKAGE_VERSION=$(node -p "require('./package.json').version")
            DEB_VERSION="${PACKAGE_VERSION}-$(date +%Y%m%d)-$(git rev-parse --short HEAD)"
          fi

          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "## 🔍 APT Repository Dry Run Summary" >> $GITHUB_STEP_SUMMARY
            echo "**Would create**: APT repository for CACI v$DEB_VERSION" >> $GITHUB_STEP_SUMMARY
            echo "**GPG Key**: ${{ secrets.GPG_PRIVATE_KEY != '' && 'Production key configured' || 'Would use temporary key' }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "## 📦 APT Repository Creation Complete" >> $GITHUB_STEP_SUMMARY
            echo "**Created**: APT repository for CACI v$DEB_VERSION" >> $GITHUB_STEP_SUMMARY
            echo "**GPG Key**: ${{ secrets.GPG_PRIVATE_KEY != '' && 'Signed with production key' || 'Signed with temporary key' }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Quick Installation" >> $GITHUB_STEP_SUMMARY
            echo '```bash' >> $GITHUB_STEP_SUMMARY
            echo "curl -fsSL https://github.com/elad12390/claude-code-configurator/releases/latest/download/install-caci-apt.sh | sudo bash" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Manual Installation" >> $GITHUB_STEP_SUMMARY
            echo '```bash' >> $GITHUB_STEP_SUMMARY
            echo "# 1. Add GPG key" >> $GITHUB_STEP_SUMMARY
            echo "curl -fsSL https://github.com/elad12390/claude-code-configurator/releases/latest/download/caci-archive-keyring.gpg | sudo gpg --dearmor -o /usr/share/keyrings/caci-archive-keyring.gpg" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "# 2. Add repository" >> $GITHUB_STEP_SUMMARY
            echo 'echo "deb [signed-by=/usr/share/keyrings/caci-archive-keyring.gpg] https://github.com/elad12390/claude-code-configurator/releases/latest/download/apt-repo stable main" | sudo tee /etc/apt/sources.list.d/caci.list' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "# 3. Install" >> $GITHUB_STEP_SUMMARY
            echo "sudo apt update && sudo apt install caci" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Features" >> $GITHUB_STEP_SUMMARY
            echo "- 🔐 **GPG-signed packages** for security" >> $GITHUB_STEP_SUMMARY
            echo "- 🔄 **Automatic updates** via \`apt upgrade\`" >> $GITHUB_STEP_SUMMARY
            echo "- 🏗️ **Professional structure** (pool/dists)" >> $GITHUB_STEP_SUMMARY
            echo "- 📱 **Multi-architecture** support (amd64, arm64)" >> $GITHUB_STEP_SUMMARY
            echo "- 🔧 **Development build**: $DEB_VERSION" >> $GITHUB_STEP_SUMMARY
          fi
